const SYN: &str = include_str!("../syn.json");
fn main() -> Result<()> {
    let defs: Definitions = serde_json::from_str(SYN).unwrap();
    generate(&defs)
}

use std::{
    fs,
    io::{Result, Write},
    path::Path,
};

use proc_macro2::{Ident, Span, TokenStream};
use quote::{format_ident, quote};
use syn_codegen::{Data, Definitions, Node, Type};

const DEBUG_SRC: &str = "src/impls/syn/gen.rs";

pub fn lookup_node<'a>(defs: &'a Definitions, name: &str) -> &'a Node {
    for node in &defs.types {
        if node.ident == name {
            return node;
        }
    }
    panic!("not found: {}", name)
}

pub fn write<P: AsRef<Path>>(path: P, content: TokenStream) -> Result<()> {
    let mut formatted = Vec::new();
    writeln!(
        formatted,
        "// This file is @generated by dbg-pls-internal-codegen."
    )?;
    writeln!(formatted, "// It is not intended for manual editing.")?;
    writeln!(formatted)?;

    let syntax_tree: syn::File = syn::parse2(content).unwrap();
    let pretty = prettyplease::unparse(&syntax_tree);
    write!(formatted, "{}", pretty)?;

    if path.as_ref().is_file() && fs::read(&path)? == formatted {
        return Ok(());
    }

    fs::write(path, formatted)?;
    Ok(())
}

fn expand_impl_body(node: &Node) -> TokenStream {
    let type_name = &node.ident;
    let ident = Ident::new(type_name, Span::call_site());

    match &node.data {
        Data::Enum(variants) => {
            let arms = variants.iter().map(|(variant_name, fields)| {
                let variant = Ident::new(variant_name, Span::call_site());
                if fields.is_empty() {
                    quote! {
                        syn::#ident::#variant => f.debug_ident(#variant_name),
                    }
                } else {
                    let pats = (0..fields.len())
                        .map(|i| format_ident!("v{}", i))
                        .collect::<Vec<_>>();
                    quote! {
                        syn::#ident::#variant(#(#pats),*) => {
                            f.debug_tuple_struct(#variant_name)#(.field(#pats))*.finish();
                        }
                    }
                }
            });
            let nonexhaustive = if node.exhaustive {
                None
            } else {
                Some(quote! {
                    _ => unreachable!(),
                })
            };
            quote! {
                match self {
                    #(#arms)*
                    #nonexhaustive
                }
            }
        }
        Data::Struct(fields) => {
            let fields = fields.iter().map(|(f, t)| {
                let ident = Ident::new(f, Span::call_site());

                if let Type::Syn(s) = t {
                    if s == "Reserved" {
                        return quote! {};
                    }
                }
                quote! {
                    .field(#f, &self.#ident)
                }
            });
            quote! {
                f.debug_struct(#type_name)
                    #(#fields)*
                    .finish();
            }
        }
        Data::Private => unreachable!(),
    }
}

fn expand_impl(node: &Node) -> TokenStream {
    let manual_debug = node.data == Data::Private || node.ident == "LitBool";
    if manual_debug {
        return TokenStream::new();
    }

    let ident = Ident::new(&node.ident, Span::call_site());
    let body = expand_impl_body(node);

    quote! {
        impl DebugPls for syn::#ident {
            fn fmt(&self, f: Formatter<'_>) {
                #body
            }
        }
    }
}

pub fn generate(defs: &Definitions) -> Result<()> {
    let mut impls = quote! {
        #![allow(clippy::too_many_lines)]
        use crate::{DebugPls, Formatter};

    };
    for node in &defs.types {
        impls.extend(expand_impl(node));
    }
    for token in defs.tokens.keys() {
        let ident = Ident::new(token, Span::call_site());
        impls.extend(quote! {
            impl DebugPls for syn::token::#ident {
                fn fmt(&self, f: Formatter<'_>) {
                    f.debug_ident(#token);
                }
            }
        });
    }

    write(DEBUG_SRC, impls)
}
